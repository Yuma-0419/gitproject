--対象URL
　https://github.com/PortillaXpert/SQL-AND-PL-SQL/blob/main/SQL/Joins_aggs.sql
--文字数
　約90行

--備考
　固有名詞等にスペイン語がつかわれているためGoogle翻訳で単語を調べて解析
　分からない部分・不明瞭な部分は「？」を記載

--コード

-- =============================================================
-- PRACTICE 4: Retrieving Data from Multiple Tables Using JOIN
-- =============================================================

-- 1. Unique list of job titles in department 30 with department location
SELECT DISTINCT e.Emp_Cargo, d.Dep_Localizacion
FROM Empleados e
JOIN Departamentos d ON e.Dep_Id = d.Dep_Id
WHERE e.Dep_Id = 30;

従業員テーブルと部門テーブルを部門IDで結合
部門IDが30のデータを対象に、役職と場所の値を重複を取り除いて取得する
→部門IDが30の従業員の役職と勤務地を重複を取り除いて取得するSQL

-- 2. Employee and their manager info
SELECT e.Emp_Nombre AS Empleado, e.Emp_Id AS "Emp#",
       j.Emp_Nombre AS Jefe, e.Emp_Jefe AS "Jefe#"
FROM Empleados e
JOIN Empleados j ON e.Emp_Jefe = j.Emp_Id;

従業員テーブルを上司ID？と従業員IDで自己結合
従業員名と従業員ID、それに結びつく上司名と上司ID？を取得する
→従業員の名前とID、その従業員の上司の名前とIDを取得するSQL

-- 3. Same as above, but includes President with no manager
SELECT e.Emp_Nombre AS Empleado, e.Emp_Id AS "Emp#",
       COALESCE(j.Emp_Nombre, '---') AS Jefe, e.Emp_Jefe AS "Jefe#"
FROM Empleados e
LEFT JOIN Empleados j ON e.Emp_Jefe = j.Emp_Id
ORDER BY e.Emp_Id;

従業員テーブルを従業員IDと上司ID？で自己結合（左外部結合）
従業員名と従業員ID、それに結びつく上司名（値がnullの場合は「---」）と上司ID？を取得する
→上司側の情報を軸に従業員の名前とID、その従業員の上司の名前とIDを取得するSQL（上司名の値がnullの場合は---と表示される）

-- 4. Employees hired after SANCHEZ
-- Oracle syntax
SELECT e.Emp_Nombre, e.Emp_FechaContrato
FROM Empleados e
JOIN Empleados s ON e.Emp_FechaContrato > s.Emp_FechaContrato
WHERE s.Emp_Nombre = 'SANCHEZ'
ORDER BY e.Emp_FechaContrato;

従業員テーブルを、入社日＞サンチェスという従業員の入社日という条件で自己結合
従業員名と入社日を入社日の昇順で取得する
　→サンチェスより後に入社した従業員の従業員名と入社日を入社日順で取得するSQL

-- SQL-1999 syntax
SELECT e.Emp_Nombre, e.Emp_FechaContrato
FROM Empleados e
JOIN Empleados s ON s.Emp_Nombre = 'SANCHEZ'
WHERE e.Emp_FechaContrato > s.Emp_FechaContrato
ORDER BY e.Emp_FechaContrato;

従業員テーブルを、入社日＞サンチェスという従業員の入社日という条件で自己結合
従業員名と入社日を入社日の昇順で取得する
　→サンチェスより後に入社した従業員の従業員名と入社日を入社日順で取得するSQL
　　＊上のSQLと内容は同じ。ONの条件と、WHEREの条件を入れ替えた形（SQL1999での構文？）

-- 5. Employees hired before their managers
-- Oracle syntax
SELECT e.Emp_Nombre AS "Empleado", e.Emp_FechaContrato AS "Fecha de contrato Empleado",
       j.Emp_Nombre AS "Jefe", j.Emp_FechaContrato AS "Fecha de contrato Jefe"
FROM Empleados e
JOIN Empleados j ON e.Emp_Jefe = j.Emp_Id
WHERE e.Emp_FechaContrato < j.Emp_FechaContrato;

従業員テーブルを上司ID？と従業員IDで自己結合
上司の入社日＜従業員の入社日の条件で、従業員名と入社日、それに結びつく上司名と上司の入社日を取得する
　→部下が上司より先に入社しているという条件で、部下の名前と入社日、上司の名前と入社日を取得するSQL

-- SQL-1999 syntax (same)
SELECT e.Emp_Nombre AS Empleado, e.Emp_FechaContrato AS "Fecha de contrato Empleado",
       j.Emp_Nombre AS Jefe, j.Emp_FechaContrato AS "Fecha de contrato Jefe"
FROM Empleados e
JOIN Empleados j ON e.Emp_Jefe = j.Emp_Id
WHERE e.Emp_FechaContrato < j.Emp_FechaContrato;

　＊上と同義。SQL1999の構文？のため割愛

-- =============================================================
-- PRACTICE 5: Aggregating Data Using Group Functions
-- =============================================================

-- 1. Salary stats across all employees
SELECT ROUND(MAX(Emp_Salario)) AS Maximo,
       ROUND(MIN(Emp_Salario)) AS Minimo,
       ROUND(SUM(Emp_Salario)) AS Suma,
       ROUND(AVG(Emp_Salario)) AS Promedio
FROM Empleados;

従業員テーブルから
給料の最大値、最低値、総額、平均値を四捨五入して取得する
　→給料の最大値、最低値、総額、平均値を四捨五入して取得するSQL

-- 2. Same stats grouped by job title
SELECT Emp_Cargo,
       ROUND(MAX(Emp_Salario)) AS Maximo,
       ROUND(MIN(Emp_Salario)) AS Minimo,
       ROUND(SUM(Emp_Salario)) AS Suma,
       ROUND(AVG(Emp_Salario)) AS Promedio
FROM Empleados
GROUP BY Emp_Cargo;

従業員テーブルから
役職でグループ化して、役職名、給料の最大値、最低値、総額、平均値を四捨五入して取得する
　→役職ごとの給料の最大値、最低値、総額、平均値を四捨五入して取得するSQL

-- 3. Managers with min salary >= 1,300,000
SELECT e.Emp_Jefe AS "Jefe#",
       MIN(e.Emp_Salario) AS Salario_Minimo
FROM Empleados e
WHERE e.Emp_Jefe IS NOT NULL
GROUP BY e.Emp_Jefe
HAVING MIN(e.Emp_Salario) >= 1300000
ORDER BY Salario_Minimo DESC;

-- 4. Department summary: name, location, # employees, avg salary
SELECT d.Dep_Nombre AS Nombre,
       d.Dep_Localizacion AS Localización,
       COUNT(e.Emp_Id) AS "Número de Empleados",
       ROUND(AVG(e.Emp_Salario), 1) AS Salario
FROM Departamentos d
LEFT JOIN Empleados e ON d.Dep_Id = e.Dep_Id
GROUP BY d.Dep_Nombre, d.Dep_Localizacion
ORDER BY d.Dep_Nombre;

-- 5. Pivot table: total salary per position by department (10, 20, 30)
SELECT e.Emp_Cargo AS "Position",
       SUM(CASE WHEN e.Dep_Id = 10 THEN e.Emp_Salario ELSE 0 END) AS "Department 10",
       SUM(CASE WHEN e.Dep_Id = 20 THEN e.Emp_Salario ELSE 0 END) AS "Department 20",
       SUM(CASE WHEN e.Dep_Id = 30 THEN e.Emp_Salario ELSE 0 END) AS "Department 30"
FROM Empleados e
WHERE e.Dep_Id IN (10, 20, 30)
GROUP BY e.Emp_Cargo;


-- =============================================================
-- PRACTICE 6: Subqueries
-- =============================================================

-- 1. Employees in same department as JIMENEZ (excluding JIMENEZ)
SELECT Emp_Nombre, Emp_FechaContrato
FROM Empleados
WHERE Dep_Id = (SELECT Dep_Id FROM Empleados WHERE Emp_Nombre = 'JIMENEZ')
  AND Emp_Nombre != 'JIMENEZ';

-- 2. Employees working in any department of employees whose name contains 'P'
SELECT Emp_Id, Emp_Nombre
FROM Empleados
WHERE Dep_Id IN (
  SELECT Dep_Id FROM Empleados WHERE Emp_Nombre LIKE '%P%'
);

-- 3. Employees in departments located in CALI
SELECT e.Emp_Nombre, e.Emp_Cargo, e.Dep_Id
FROM Empleados e
JOIN Departamentos d ON e.Dep_Id = d.Dep_Id
WHERE d.Dep_Localizacion = 'CALI';

-- 4. Employees managed by LOPEZ
SELECT Emp_Nombre, Emp_Salario
FROM Empleados
WHERE Emp_Jefe = (
  SELECT Emp_Id FROM Empleados WHERE Emp_Nombre = 'LOPEZ'
);

-- 5. Employees in department named CONTABILIDAD
SELECT d.Dep_Id, e.Emp_Nombre, e.Emp_Cargo
FROM Departamentos d
JOIN Empleados e ON d.Dep_Id = e.Dep_Id
WHERE d.Dep_Nombre = 'CONTABILIDAD';
